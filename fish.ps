%! 

%%% A postscript about recursive fish.

%% The letter F

/draw-f {
  newpath
  0.30 0.20 moveto 
  0.40 0.20 lineto
  0.40 0.45 lineto
  0.60 0.45 lineto
  0.60 0.55 lineto
  0.40 0.55 lineto
  0.40 0.70 lineto
  0.70 0.70 lineto
  0.70 0.80 lineto
  0.30 0.80 lineto
  closepath
  0.01 setlinewidth
  stroke 
} def

% [x y]
/vlength {
  aload pop      % x y
  dup mul        % x y*y
  exch           % y*y x
  dup mul        % y*y x*x
  add 
  sqrt 
} def 

% Consumes: a procedure that draws lines for a picture.
% Produces: a picture-procedure that consumes a box and draws a picture.
/create-picture {    % bx
  [ exch             % [ d 
    { 
      gsave
      exch           % d bx 
      aload pop      % d a b c 
      3 -1 roll      % d b c a
      aload pop      % d b c xa ya
      translate      % d b c 
      vlength        % d b cl
      exch           % d cl b
      dup            % d cl b b 
      vlength        % d cl b bl 
      3 1 roll       % d bl cl b 
      aload pop      % d bl cl xb yb
      exch atan      % d bl cl ag
      rotate         % d bl cl 
      scale          % d
      exec           % 
      grestore       
    } /exec cvx 
  ] cvx 
} def 

%% [x y] f -> [x' y'] where x' = x * f, y' = y * f 
/vscale {
  exch           % f [x y]
  aload pop      % f x y
  2 index        % f x y f 
  mul            % f x y', y' = y * f
  3 1 roll       % y' f x
  mul            % y' x', x' = f * x
  exch           % x' y'
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 + x2, y = y1 + y2
/vadd {
  aload pop      % [x1 y1] x2 y2
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2
  add            % y2 y1 x', x' = x1 + x2 
  3 1 roll       % x' y2 y1
  add            % x' y', y' = y2 + y1
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x1 y1] [x2 y2] -> [x y], where x = x1 - x2, y = y1 - y2
/vsub {
  aload pop      % [x1 y1] x2 y2 
  3 2 roll       % x2 y2 [x1 y1]
  aload pop      % x2 y2 x1 y1
  exch           % x2 y2 y1 x1
  4 -1 roll      % y2 y1 x1 x2 
  sub            % y2 y1 x', x' = x1 - x2
  3 1 roll       % x' y2 y1 
  exch           % x' y1 y2 
  sub            % x' y', y' = y1 - y2 
  2 array        % x' y' [. .]
  astore         % [x' y']
} def

%% [x y] -> [x' y'] where x' = -x, y' = -y
/vneg {
  aload pop      % x y
  neg            % x -y
  exch           % -y x
  neg            % -y -x
  exch           % -x -y 
  2 array        % -x -y [. .]
  astore         % [-x -y] 
} def

%% (a + b, c, -b)
%% [ [xa ya] [xb yb] [xc yc] ]
/turn-box { 
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  4 -1 roll      % [xc yc] [xb yb] [xb yb] [xa ya]
  vadd           % [xc yc] [xb yb] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [xc yc] [xb yb]
  vneg           % [xa+xb ya+yb] [xc yc] [-xb -yb]
  3 array        % [xa+xb ya+yb] [xc yc] [-xb -yb] [. . .]
  astore         % [ [xa+xb ya+yb] [xc yc] [-xb -yb] ]
} def

%% (a + b, -b, c)
%% [ [xa ya] [xb yb] [xc yc] ]
/flip-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  exch           % [xa ya] [xc yc] [xb yb]
  dup            % [xa ya] [xc yc] [xb yb] [xb yb]
  vneg           % [xa ya] [xc yc] [xb yb] [-xb -yb]
  3 1 roll       % [xa ya] [-xb -yb] [xc yc] [xb yb] 
  4 -1 roll      % [-xb -yb] [xc yc] [xb yb] [xa ya]
  vadd           % [-xb -yb] [xc yc] [xa+xb ya+yb]
  3 1 roll       % [xa+xb ya+yb] [-xb -yb] [xc yc]
  3 array        % [xa+xb ya+yb] [-xb -yb] [xc yc] [. . .]
  astore         % [ [xa+xb ya+yb] [-xb -yb] [xc yc] ]
} def

%% (a’, b’, c’) = (a + (b + c) / 2, (b + c) / 2, (c − b) / 2)
%% [ [xa ya] [xb yb] [xc yc] ]
/toss-box {
  aload pop      % [xa ya] [xb yb] [xc yc]
  2 copy         % [xa ya] [xb yb] [xc yc] [xb yb] [xc yc] 
  exch           % [xa ya] [xb yb] [xc yc] [xc yc] [xb yb]
  vsub           % [xa ya] [xb yb] [xc yc] [xc-xb yc-yb]
  0.5 vscale     % [xa ya] [xb yb] [xc yc] [(xc-xb)/2 (yc-yb)/2]
  4 1 roll       % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb yb] [xc yc]
  vadd           % [(xc-xb)/2 (yc-yb)/2] [xa ya] [xb+xc yb+yc]
  0.5 vscale     % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  dup            % [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2] [(xb+xc)/2 (yb+yc)/2]
  4 1 roll       % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa ya] [(xb+xc)/2 (yb+yc)/2]
  vadd           % [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [xa+(xb+xc)/2 ya+(yb+yc)/2]
  3 1 roll       % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2]
  3 array        % [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] [. . .]
  astore         % [ [xa+(xb+xc)/2 ya+(yb+yc)/2] [(xb+xc)/2 (yb+yc)/2] [(xc-xb)/2 (yc-yb)/2] ]
} def

%% picture -> picture
/turn {
  [              % p [
  exch           % [ p
  /exec          % [ p /exec 
  cvx            % [ p exec 
  /turn-box      % [ p exec /turn-box 
  cvx            % [ p exec turn-box
  3 1 roll       % [ turn-box p exec
  ]              % [ turn-box p exec ]
  cvx            % { turn-box p exec }
} def

/flip {
  [              % p [
  exch           % [ p
  /exec          % [ p /exec 
  cvx            % [ p exec 
  /flip-box      % [ p exec /flip-box 
  cvx            % [ p exec flip-box
  3 1 roll       % [ flip-box p exec
  ]              % [ flip-box p exec ]
  cvx            % { flip-box p exec }
} def

/toss {
  [              % p [
  exch           % [ p
  /exec          % [ p /exec 
  cvx            % [ p exec 
  /toss-box      % [ p exec /toss-box 
  cvx            % [ p exec toss-box
  3 1 roll       % [ toss-box p exec
  ]              % [ toss-box p exec ]
  cvx            % { toss-box p exec }
} def

/some-box [ [120 80] [200 0] [0 200] ] def

/f-picture { draw-f } create-picture def

% some-box /f-picture load toss exec  
